# 第三课初探 reconciler

## 从 React 元素到 Fiber 节点

我准备了一个极其简单的应用，它将贯穿这整个系列。页面上有一个 button，每次点击将导致其右边的数字加一：
正如你所看到的，它就是一个很简单的组件，render 方法返回了两个子元素：一个 button、一个 span。点击按钮，组件的状态在事件处理函数中被修改。由此，它将更新 span 元素内的文本。

以下代码为其实现：

```jsx
class ClickCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState((state) => {
      return { count: state.count + 1 };
    });
  }

  render() {
    return [
      <button key="1" onClick={this.handleClick}>
        Update counter
      </button>,
      <span key="2">{this.state.count}</span>,
    ];
  }
}
```

每一个组件都有一个由 render 方法返回的 UI 呈现，我们可以称之以 View 或者 Template。ClickCounter 组件的 Template 如下：

```jsx
[
  <button key="1" onClick={this.handleClick}>
    Update counter
  </button>,
  <span key="2">{this.state.count}</span>,
];
```

### React Elements（React 元素）

一旦 JSX 编译器编译完一个 Template，你会得到一组 React 元素。这是经 render 方法所真正返回的内容，并不是 HTML。如果我们不想用 JSX，ClickCounter 组件 render 方法返回的内容将是：

```js
class ClickCounter {
    ...
    render() {
        return [
            React.createElement(
                'button',
                {
                    key: '1',
                    onClick: this.onClick
                },
                'Update counter'
            ),
            React.createElement(
                'span',
                {
                    key: '2'
                },
                this.state.count
            )
        ]
    }
}
```

render 方法中调用 React.createElement 将生成两个对象，其数据结构像下面这样：

```jsx
[
    {
        $$typeof: Symbol(react.element),
        type: 'button',
        key: "1",
        props: {
            children: 'Update counter',
            onClick: () => { ... }
        }
    },
    {
        $$typeof: Symbol(react.element),
        type: 'span',
        key: "2",
        props: {
            children: 0
        }
    }
]
```

你可以看到 React 给这些对象添加了属性 $$typeof，以标识它们是 React 元素。然后，我们有属性 type、key、props，以描述元素。这些值取决于你传入 React.createElement 的参数。特别注意一下，对于 button 和 span 元素的 textContent 属性，React 是如何表达的。对于 button 元素的 click 事件处理函数，React 又是如何表达的。还有其它的一些属性，如 ref，这超出了本文的范畴。

由 ClickCounter 组件生成的元素没有任何 props 和 key：

```jsx
{
    $$typeof: Symbol(react.element),
    key: null,
    props: {},
    ref: null,
    type: ClickCounter
}
```

## fiber node structure（fiber 节点的数据结构）

现在，我们来看看由 ClickCounter 创建来的 fiber 节点的数据结构：

```js
{
    stateNode: new ClickCounter,
    type: ClickCounter,
    alternate: null,
    key: null,
    updateQueue: null,
    memoizedState: {count: 0},
    pendingProps: {},
    memoizedProps: {},
    tag: 1,
    effectTag: 0,
    nextEffect: null
}
```

以及 span 这个 DOM 元素的 fiber node：

```js
{
    stateNode: new HTMLSpanElement,
    type: "span",
    alternate: null,
    key: "2",
    updateQueue: null,
    memoizedState: null,
    pendingProps: {children: 0},
    memoizedProps: {children: 0},
    tag: 5,
    effectTag: 0,
    nextEffect: null
}
```

### reconciliation

在整个 reconciliation 期间，React 会存在大量的操作。比如，本示例中，在组件首次渲染以及状态更新之后，React 会存在以下几个操作：

- 更新组件 ClickCounter 状态中的 count 属性
- 获取并比较 ClickCounter 的子节点以及它们的属性
- 更新 span 元素的属性

每一个操作都对应着一个 fiber node。fiber node 是 React 内部用于表示组件以及 DOM 元素的基本单元。每一个 fiber node 都包含了足够的信息，以便 React 能够高效地进行更新和渲染。

## Reconciler 简介

![intrp](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b1913d7f87e4067ae1fffd42eb5ea93~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.jpg#?w=1818&h=604&s=142700&e=png&b=f5f3ef)

`Reconciler` 的中文名叫协调器，它负责处理 `React` 元素的更新并在内部构建虚拟 DOM，这个过程是 `React` 框架实现高效的 UI 渲染和更新的核心逻辑所在。以下是 `Reconciler` 主要做的事情：

- 接收并解析 React 元素： Reconciler 接收 JSX 或者 createElement 函数返回的 React 元素，并将其解析成虚拟 DOM 树的结构。
- 协调更新： 比较新旧虚拟 DOM 树的差异，确定哪些部分需要更新，并生成更新计划。
- 构建虚拟 DOM 树： 在组件更新时，根据生成的更新计划，Reconciler 会更新虚拟 DOM 树的结构以反映最新的组件状态。
- 生成 DOM 更新指令： 将更新后的虚拟 DOM 树转换为真实的 DOM 更新指令，描述了如何将变更应用到实际的 DOM 树上。

## 实现 Fiber Node

`FiberNode`（纤维节点）是 Reconciler 的核心数据结构之一，用于构建协调树。Reconciler 使用 `FiberNode` 来表示 React 元素树中的节点，并通过比较 Fiber 树的差异，找出需要进行更新的部分，生成更新指令，来实现 UI 的渲染和更新。
![fiber node](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9af062a84b3744958f775228e5c9b30e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.jpg#?w=1139&h=817&s=73251&e=png&b=f5f3ef)

每个 FiberNode 都表示着 React 元素树中的一个节点，它包含了以下几个重要的字段：

- type：节点的类型，可以是原生 DOM 元素、函数组件或类组件等；
- props：节点的属性，包括 DOM 元素的属性、函数组件的 props 等；
- pendingProps：表示节点的新属性，用于在协调过程中进行更新。
- stateNode：节点对应的实际 DOM 节点或组件实例；
- child：指向节点的第一个子节点；
- sibling：指向节点的下一个兄弟节点；
- return：指向节点的父节点；
- alternate：指向节点的备份节点，用于在协调过程中进行比较；
- effectTag：表示节点的副作用类型，如更新、插入、删除等；

## 实现 Reconciler 工作流程

```
setState()
   ↓
更新对象加入 updateQueue
   ↓
scheduleUpdateOnFiber()
   ↓
beginWork(root)
   ↓
createWorkInProgress(current, pendingProps)
   ↓
reconcileChildren(current.child, newElements)
   ↓
completeWork()
   ↓
生成 workInProgress Fiber 树
   ↓
commitWork(effectList)
   ↓
root.current = workInProgress
```

![workloop](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0485c4c0e8314674a097990124f65010~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.jpg#?w=1401&h=678&s=124117&e=png&b=f5f3ef)

`Reconciler` 的工作流程总的来说就是对 Fiber 树进行一次 `深度优先遍历（DFS）` ，首先访问根节点，然后依次访问左子树和右子树，通过比较新节点（新生成的 `React Element`）和旧节点（现有的 `FiberNode`），生成更新计划，并打上不同的标记。

1. **遍历 Fiber 树**：React 使用深度优先搜索（DFS）算法来遍历 Fiber 树，首先会从 Fiber 树的根节点开始进行遍历，遍历整个组件树的结构。

2. **比较新旧节点**：对于每个 Fiber 节点，Reconciler 会比较新节点（即新的 React Element）和旧节点（即现有的 FiberNode）之间的差异，比较的内容包括节点类型、属性、子节点等方面的差异。

3. **生成更新计划**：根据比较的结果，Reconciler 会生成一个更新计划，用于确定需要进行的操作，更新计划通常包括哪些节点需要更新、哪些节点需要插入到 DOM 中、哪些节点需要删除等信息。

4. **打标记（Tagging）**：为了记录不同节点的操作，React 会为每个节点打上不同的标记。例如，如果节点需要更新，可能会打上更新标记（Update Tag）；如果节点是新创建的，可能会打上插入标记（Placement Tag）；如果节点被移除，可能会打上删除标记（Deletion Tag）等。

5. **更新 Fiber 节点**：根据生成的更新计划和标记，Reconciler 会更新对应的 Fiber 节点以反映组件的最新状态。更新操作可能包括更新节点的状态、更新节点的属性、调用生命周期方法等。

6. **递归处理子节点**：对于每个节点的子节点，React 会递归地重复进行上述的比较和更新操作，以确保整个组件树都得到了正确的处理。

当所有 React Element 都比较完成之后，会生成一棵新的 Fiber 树，此时，一共存在两棵 Fiber 树：

- current: 与视图中真实 UI 对应的 Fiber 树，当 React 开始新的一轮渲染时，会使用 current 作为参考来比较新的树与旧树的差异，决定如何更新 UI；
- workInProgress: 触发更新后，正在 Reconciler 中计算的 Fiber 树，一旦 workInProgress 上的更新完成，它将会被提交为新的 current，成为下一次渲染的参考树，并清空旧的 current 树。

下面我们来实现一下 Reconciler 的完整工作流程。
