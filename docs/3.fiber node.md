# 第三课初探 reconciler

## 从 React 元素到 Fiber 节点

我准备了一个极其简单的应用，它将贯穿这整个系列。页面上有一个 button，每次点击将导致其右边的数字加一：
正如你所看到的，它就是一个很简单的组件，render 方法返回了两个子元素：一个 button、一个 span。点击按钮，组件的状态在事件处理函数中被修改。由此，它将更新 span 元素内的文本。

以下代码为其实现：

```jsx
class ClickCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState((state) => {
      return { count: state.count + 1 };
    });
  }

  render() {
    return [
      <button key="1" onClick={this.handleClick}>
        Update counter
      </button>,
      <span key="2">{this.state.count}</span>,
    ];
  }
}
```

每一个组件都有一个由 render 方法返回的 UI 呈现，我们可以称之以 View 或者 Template。ClickCounter 组件的 Template 如下：

```jsx
[
  <button key="1" onClick={this.handleClick}>
    Update counter
  </button>,
  <span key="2">{this.state.count}</span>,
];
```

### React Elements（React 元素）

一旦 JSX 编译器编译完一个 Template，你会得到一组 React 元素。这是经 render 方法所真正返回的内容，并不是 HTML。如果我们不想用 JSX，ClickCounter 组件 render 方法返回的内容将是：

```js
class ClickCounter {
    ...
    render() {
        return [
            React.createElement(
                'button',
                {
                    key: '1',
                    onClick: this.onClick
                },
                'Update counter'
            ),
            React.createElement(
                'span',
                {
                    key: '2'
                },
                this.state.count
            )
        ]
    }
}
```

render 方法中调用 React.createElement 将生成两个对象，其数据结构像下面这样：

```jsx
[
    {
        $$typeof: Symbol(react.element),
        type: 'button',
        key: "1",
        props: {
            children: 'Update counter',
            onClick: () => { ... }
        }
    },
    {
        $$typeof: Symbol(react.element),
        type: 'span',
        key: "2",
        props: {
            children: 0
        }
    }
]
```

你可以看到 React 给这些对象添加了属性 `$$typeof`，以标识它们是 React 元素。然后，我们有属性 type、key、props，以描述元素。这些值取决于你传入 React.createElement 的参数。特别注意一下，对于 button 和 span 元素的 textContent 属性，React 是如何表达的。对于 button 元素的 click 事件处理函数，React 又是如何表达的。还有其它的一些属性，如 ref，这超出了本文的范畴。

由 ClickCounter 组件生成的元素没有任何 props 和 key：

```jsx
{
    $$typeof: Symbol(react.element),
    key: null,
    props: {},
    ref: null,
    type: ClickCounter
}
```

## fiber node structure（fiber 节点的数据结构）

现在，我们来看看由 ClickCounter 创建来的 fiber 节点的数据结构：

```js
{
    stateNode: new ClickCounter,
    type: ClickCounter,
    alternate: null,
    key: null,
    updateQueue: null,
    memoizedState: {count: 0},
    pendingProps: {},
    memoizedProps: {},
    tag: 1,
    effectTag: 0,
    nextEffect: null
}
```

以及 span 这个 DOM 元素的 fiber node：

```js
{
    stateNode: new HTMLSpanElement,
    type: "span",
    alternate: null,
    key: "2",
    updateQueue: null,
    memoizedState: null,
    pendingProps: {children: 0},
    memoizedProps: {children: 0},
    tag: 5,
    effectTag: 0,
    nextEffect: null
}
```

### reconciliation

在整个 reconciliation 期间，React 会存在大量的操作。比如，本示例中，在组件首次渲染以及状态更新之后，React 会存在以下几个操作：

- 更新组件 ClickCounter 状态中的 count 属性
- 获取并比较 ClickCounter 的子节点以及它们的属性
- 更新 span 元素的属性

每一个操作都对应着一个 Fiber Node。它是 React 内部用于表示组件以及 DOM 元素的基本单元。每一个 Fiber node 都包含了足够的信息，以便 React 能够高效地进行更新和渲染。

## Reconciler 简介

![intrp](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b1913d7f87e4067ae1fffd42eb5ea93~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.jpg#?w=1818&h=604&s=142700&e=png&b=f5f3ef)

`Reconciler` 的中文名叫协调器，它负责处理 `React` 元素的更新并在内部构建虚拟 DOM，这个过程是 `React` 框架实现高效的 UI 渲染和更新的核心逻辑所在。以下是 `Reconciler` 主要做的事情：

- 接收并解析 React 元素： Reconciler 接收 JSX 或者 createElement 函数返回的 React 元素，并将其解析成虚拟 DOM 树的结构。
- 协调更新： 比较新旧虚拟 DOM 树的差异，确定哪些部分需要更新，并生成更新计划。
- 构建虚拟 DOM 树： 在组件更新时，根据生成的更新计划，Reconciler 会更新虚拟 DOM 树的结构以反映最新的组件状态。
- 生成 DOM 更新指令： 将更新后的虚拟 DOM 树转换为真实的 DOM 更新指令，描述了如何将变更应用到实际的 DOM 树上。

## 实现 Fiber Node

`FiberNode`是 Reconciler 的核心数据结构之一，用于构建协调树。Reconciler 使用 `FiberNode` 来表示 React 元素树中的节点，并通过比较 Fiber 树的差异，找出需要进行更新的部分，生成更新指令，来实现 UI 的渲染和更新。

![fiber node](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9af062a84b3744958f775228e5c9b30e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.jpg#?w=1139&h=817&s=73251&e=png&b=f5f3ef)

每个 FiberNode 都表示着 React 元素树中的一个节点，它包含了以下几个重要的字段：

- type：节点的类型，可以是原生 DOM 元素、函数组件或类组件等；
- props：节点的属性，包括 DOM 元素的属性、函数组件的 props 等；
- pendingProps：表示节点的新属性，用于在协调过程中进行更新。
- stateNode：节点对应的实际 DOM 节点或组件实例；
- child：指向节点的第一个子节点；
- sibling：指向节点的下一个兄弟节点；
- return：指向节点的父节点；
- alternate：指向节点的备份节点，用于在协调过程中进行比较；
- effectTag：表示节点的副作用类型，如更新、插入、删除等；

## 实现 Reconciler 工作流程

```
setState()和render函数触发更新
   ↓
更新对象加入 updateQueue
   ↓
scheduleUpdateOnFiber()：主要是找到hostFiberNode, 然后开始reconciler过程。
   ↓
beginWork(root)
   ↓
createWorkInProgress(current, pendingProps)
   ↓
reconcileChildren(current.child, newElements)
   ↓
completeWork()
   ↓
生成 workInProgress Fiber 树
   ↓
commitWork(effectList)
   ↓
root.current = workInProgress
```

```
workLoop()
  └── performUnitOfWork(workInProgress)
        ├── beginWork(current, workInProgress)
        └── completeUnitOfWork(workInProgress)
```

每个节点都会执行 beginWork()：
• 对比当前 Fiber 和它的子元素（reconcileChildren()）
• 根据新 props 创建新的子 Fiber 节点（或复用旧的）

### 开始调用 scheduleUpdateOnFiber

接受 FiberNode 开始执行我们的渲染工作, 一开始渲染传入的是 hostFiberNode。之后章节 dispatch 触发更新，传递的是对应的 fiberNode

```js
export function scheduleUpdateOnFiber(fiber: FiberNode) {
  const root = markUpdateFromFiberToRoot(fiber);
  renderRoot(root);
}
```

从上面我们可以看到调用了`scheduleUpdateOnFiber`方法，开始从根部渲染页面。scheduleUpdateOnFiber 主要是执行了 2 个方法：

1. `markUpdateFromFiberToRoot`: 由于我们更新的节点可能不是`hostfiberNode`， 这个方法就是不管传入的是那个节点，返回我们的根节点`rootFiberNode`

2. `renderRoot`: 这里是我们 wookLoop 的入口，也是调和完成后，将生成的 fiberNode 树，赋值给 finishedWork，进入 commit 的入口。

### wookLoop

执行完上面的操作后，接下来进入的调和 reconciler 阶段。开始我们要明白一些关键词:

- workInProgress: 表示当前正在调和的 fiber 节点，之后简称 wip

- beginWork: 主要是根据当前 fiberNode 创建子 fiberNode 以及 在 update 时标记 placement（新增、移动）ChildDeletion(删除)

- completeWork: 在 mount 时构建离屏 Dom Tree, 初始化属性，在 update 时标记 Update(属性更新）、执行 flags 冒泡

![workloop](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0485c4c0e8314674a097990124f65010~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.jpg#?w=1401&h=678&s=124117&e=png&b=f5f3ef)

#### beginWork 开始

主要是向下进行遍历，创建不同的 fiberNode。初始化我们传入的是 HostRoot，所以会走到 updateHostRoot 分支

```js
/**
 * 递归中的递阶段
 * 比较 然后返回子fiberNode 或者null
 */
export const beginWork = (wip: FiberNode) => {
  switch (wip.tag) {
    case HostRoot:
      return updateHostRoot(wip);
    case HostComponent:
      return updateHostComponent(wip);
    case HostText:
      // 文本节点没有子节点，所以没有流程
      return null;
    default:
      if (__DEV__) {
        console.warn("beginWork未实现的类型");
      }
      break;
  }
  return null;
};
```

##### updateHostRoot

这个方法主要是 2 个部分：

1. 根据上面步骤创建的更新队列获取到更新的内容
2. 根据 ReactELment 执行 reconcileChildren 创建子 fiberNode

```js
/**
  processUpdateQueue： 是根据不同的类型（函数和其他）生成memoizedState
*/
function updateHostRoot(wip: FiberNode) {
  const baseState = wip.memoizedState;
  const updateQueue = wip.updateQueue as UpdateQueue<ReactElementType>;
  // 这里获取之前的更新队列
  const pending = updateQueue.shared.pending;
  updateQueue.shared.pending = null;
  const { memoizedState } = processUpdateQueue(baseState, pending); // 最新状态
  wip.memoizedState = memoizedState; // 其实就是传入的element <App />

  const nextChildren = wip.memoizedState; // 就是我们传入的ReactElement 对象
  reconcileChildren(wip, nextChildren);
  return wip.child;
}
```

##### reconcileChildren 调和子节点

根据是否存在`alternate`(是否是初始化），分别调用不同的方法。

通过上面 `prepareFreshStack` 的执行，我们知道传入的 `hostFiber`, 此时是存在 `alternate` 属性的，所以会走到 `reconcilerChildFibers`分支。

进入`reconcilerChildFibers`后，当前传入参数是 `returnFiber`是 hostFiber 以及 `currentFiber` 为 null（初始化），`newChild`为 ReactElementType。

我们可以判断接下来会走到 reconcileSingleElement 的执行。其中 placeSingleChild 是打标记使用的，我们下一节展开讲解。

```js
/**
	wip: 当前正在执行的父fiberNode
	children: 即将要生成的子fiberNode
*/
function reconcileChildren(wip: FiberNode, children?: ReactElementType) {
  const current = wip.alternate;

  if (current !== null) {
    // update
    wip.child = reconcilerChildFibers(wip, current?.child, children);
  } else {
    // mount
    wip.child = mountChildFibers(wip, null, children);
  }
}

function reconcilerChildFibers(
    returnFiber: FiberNode,
    currentFiber: FiberNode | null,
    newChild?: ReactElementType | string | number
  ) {
    // 判断当前fiber的类型
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(
            reconcileSingleElement(returnFiber, currentFiber, newChild)
          );
        default:
          if (__DEV__) {
            console.warn("未实现的reconcile类型", newChild);
          }
          break;
      }
    }
    // Todo 多节点的情况 ul > li * 3

    // HostText
    if (typeof newChild === "string" || typeof newChild === "number") {
      return placeSingleChild(
        reconcileSingleTextNode(returnFiber, currentFiber, newChild)
      );
    }

    if (__DEV__) {
      console.warn("未实现的reconcile类型", newChild);
    }
    return null;
  };
}
```

`reconcileSingleElement`

从名字我们可以看出是通过 ReactElement 创建单一的 fiberNode。通过 reconcileSingleElement 我们就可以得出了一个新的子 fiberNode，然后通过 return 指向父 fiber。

```js
/**
 * 根据reactElement对象创建fiber并返回
 */
function reconcileSingleElement(
  returnFiber: FiberNode,
  _currentFiber: FiberNode | null,
  element: ReactElementType
) {
  const fiber = createFiberFromElement(element);
  fiber.return = returnFiber;
  return fiber;
}

export function createFiberFromElement(element: ReactElementType): FiberNode {
  const { type, key, props } = element;
  let fiberTag: WorkTag = FunctionComponent;

  if (typeof type === "string") {
    // <div/>  type : 'div'
    fiberTag = HostComponent;
  } else if (typeof type !== "function" && __DEV__) {
    console.log("未定义的type类型", element);
  }
  const fiber = new FiberNode(fiberTag, props, key);
  fiber.type = type;
  return fiber;
}
```

#### completeWork 开始

从上面的 beginWork 操作后，此时我们 wip 在文本节点 hcc 的节点位置.

##### completeWork

首次我们会接受到一个最底部的子 fiberNode，由于是第一次 mount,所以当前的 fiber 下不会存在 alternate 属性的，所以会走到构建 Dom 的流程。

```js
/**
 * 递归中的归
 */
export const completeWork = (wip: FiberNode) => {
  const newProps = wip.pendingProps;
  const current = wip.alternate;

  switch (wip.tag) {
    case HostComponent:
      if (current !== null && wip.stateNode) {
        //update
      } else {
        // 1. 构建DOM
        const instance = createInstance(wip.type, newProps);
        // 2. 将DOM插入到DOM树中
        appendAllChildren(instance, wip);
        wip.stateNode = instance;
      }
      bubbleProperties(wip);
      return null;
    case HostText:
      if (current !== null && wip.stateNode) {
        //update
      } else {
        // 1. 构建DOM
        const instance = createTextInstance(newProps.content);
        // 2. 将DOM插入到DOM树中
        wip.stateNode = instance;
      }
      bubbleProperties(wip);
      return null;
    case HostRoot:
      bubbleProperties(wip);
      return null;
    default:
      if (__DEV__) {
        console.warn("未实现的completeWork");
      }
      break;
  }
};

// 根据逻辑判断，走到下面的逻辑判断，传入了文本
// 1. 构建DOM
const instance = createTextInstance(newProps.content);
// 2. 将DOM插入到DOM树中
wip.stateNode = instance;
```

经过 completeWork 后，我们给当前的 wip 添加了 stateNode 属性，用于指向生成的 Dom 节点。

执行完 completeWork 后，继续返回到 completeUnitOfWork 中，查找 sibling 节点，目前我们 demo 中没有，所以会向上找到当前节点的 return 指向。继续执行 completeWork 工作,此时的结构变成了如下图：
!(completeWork 后)[https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6658c12fe2d446280230e059e23059a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?]

`Reconciler` 的工作流程总的来说就是对 Fiber 树进行一次 `深度优先遍历（DFS）` ，首先访问根节点，然后依次访问左子树和右子树，通过比较新节点（新生成的 `React Element`）和旧节点（现有的 `FiberNode`），生成更新计划，并打上不同的标记。

1. **遍历 Fiber 树**：React 使用深度优先搜索（DFS）算法来遍历 Fiber 树，首先会从 Fiber 树的根节点开始进行遍历，遍历整个组件树的结构。

2. **比较新旧节点**：对于每个 Fiber 节点，Reconciler 会比较新节点（即新的 React Element）和旧节点（即现有的 FiberNode）之间的差异，比较的内容包括节点类型、属性、子节点等方面的差异。

3. **生成更新计划**：根据比较的结果，Reconciler 会生成一个更新计划，用于确定需要进行的操作，更新计划通常包括哪些节点需要更新、哪些节点需要插入到 DOM 中、哪些节点需要删除等信息。

4. **打标记（Tagging）**：为了记录不同节点的操作，React 会为每个节点打上不同的标记。例如，如果节点需要更新，可能会打上更新标记（Update Tag）；如果节点是新创建的，可能会打上插入标记（Placement Tag）；如果节点被移除，可能会打上删除标记（Deletion Tag）等。

5. **更新 Fiber 节点**：根据生成的更新计划和标记，Reconciler 会更新对应的 Fiber 节点以反映组件的最新状态。更新操作可能包括更新节点的状态、更新节点的属性、调用生命周期方法等。

6. **递归处理子节点**：对于每个节点的子节点，React 会递归地重复进行上述的比较和更新操作，以确保整个组件树都得到了正确的处理。

当所有 React Element 都比较完成之后，会生成一棵新的 Fiber 树，此时，一共存在两棵 Fiber 树：

- current: 与视图中真实 UI 对应的 Fiber 树，当 React 开始新的一轮渲染时，会使用 current 作为参考来比较新的树与旧树的差异，决定如何更新 UI；
- workInProgress: 触发更新后，正在 Reconciler 中计算的 Fiber 树，一旦 workInProgress 上的更新完成，它将会被提交为新的 current，成为下一次渲染的参考树，并清空旧的 current 树。

下面我们来实现一下 Reconciler 的完整工作流程。
