上一节中我们讲解了 update 的过程中，begionWork 和 completeWork、commitWork 的具体执行流程。本节主要是讲解

1. hooks 是如何存放数据的，以及一些 hooks 的规则。
2. 一次 dispatch 触发的更新整体流程，双缓存树的运用。

我们有如下代码，在初始化的时候执行 useState 和调用 setNum 的时候，是如何更新的。

```js
function App() {
  const [num, setNum] = useState(100);
  window.setNum = setNum;
  return <div>{num}</div>;
}
```

## 1. 支持 FuctionComponent

上一节我们实现了简单版的 react-dom 包，支持了首屏渲染触发更新，而 React 还有很多触发更新的方式，如类组件的 this.setState()、函数组件的 useState useEffect，这一节我们来实现函数组件的 useState。

useState 是 React 中的一个 Hook，React Hooks 是 React 16.8 引入的一项特性，目的是让你在函数组件中使用状态和其他 React 特性，以替代类组件中的状态和生命周期方法。在函数组件中使用 Hooks 有一些规则和限制：

- 只能在函数组件中调用 Hooks： Hooks 依赖于 React 的函数组件机制，所以只能在函数组件中使用，而不能在类组件中使用。如果你需要在类组件中使用类似的功能，可以考虑使用 React 的类组件生命周期方法和状态管理机制。

- 只能在顶层调用 Hooks： 不可以在条件语句、循环语句或嵌套函数中调用 Hooks。这确保 React 能够按照相同的顺序调用 Hooks，以确保状态之间的关系保持一致。

首先，我们需要将函数组件 FunctionComponent 加入到更新流程里面去，和 HostComponet、HostText 一样，FunctionComponent 的更新流程同样根植于 beginWork 和 completeWork 函数。

先在 beginWork 函数中增加 FunctionComponent 的情况判断，若 FiberNode 是函数组件，就调用 updateFunctionComponent 函数；

## 2. 实现数据共享层

我们知道 Hooks 只能在函数组件中调用，若我们在一个 Hook 的回调函数中调用另一个 Hook 会报错，类似下面这样：

```js
function App() {
    useEffect(() => {
        useState(1)
    }
}
```

那 Hooks 如何感知被调用的上下文环境呢？

方法是在不同上下文中，调用的 Hooks 不是同一个函数。在 mount 时、update 时、以及其它上下文中，分别实现不同的 Hooks 函数，从而确保 Hooks 在正确的上下文环境中执行。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fed5a402ee434d8e8c576df658202447~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.jpg#?w=1552&h=1130&s=195435&e=png&b=f5f3ef)

我们调用 useState 时的一般语法是：

```js
import { useState } from "react";

const [state, setState] = useState(initialState);
```

可以看出，useState 是被 react 包导出，而要想感知上下文环境，则需要依赖 react-reconciler 包中的更新流程，也就是说两个包之间需要共享数据，因此就需要实现一个内部数据共享层（ReactSharedInternals）。

### 数据共享层注意事项

以浏览器举例，Reconciler + hostConfig = ReactDOM

增加「内部数据共享层」，意味着 Reconciler 与 React 产生关联，进而意味着 ReactDOM 与 React 产生关联。

如果两个包「产生关联」，在打包时需要考虑：两者的代码是打包在一起还是分开？

如果打包在一起，意味着打包后的 ReactDOM 中会包含 React 的代码，那么 ReactDOM 中会包含一个内部效据共享层，React 中也会包含一个内部数据共享层，这两者不是同一个内部数据共享层。

而我们希望两者共享数据，所以不希望 ReactDOM 中会包含 React 的代码。

所以需要在打包时在 rollup/react-dom.config.js 中增加 externals

```js

```

## hooks 原理

基于 useState 我们来讲讲 hook 在初始化和更新阶段的区别。以及 react 是如何做到 hook 不能在条件语句和函数组件外部使用的。

在 react 中，对于同一个 hook，在不同的环境都是有不同的集合区分，这样就可以做到基于不同的执行环境的不同判断。

首先有几个名词：

> currentlyRenderingFiber: 记录当前正在执行的函数组件的 fiberNode
> workInProgressHook: 当前正在执行的 hook
> currentHook：更新的时候的数据来源
> memoizedState: 对于 fiberNode.memoizedState 是存放 hooks 的指向。对于 hook.memoizedState 就是存放数据的地方。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75451b13e8fd40fdb7e99e74946af52b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### 实现 useState

包括 2 方面工作：

1. 实现 mount 时 useState 的实现
2. 实现 dispath 方法，并接入现有更新流程内
