# 第 12 课 实现 Diff 算法

当前仅实现了单一节点的增/删操作，即「单节点 Diff 算法」。本节课实现「多节点的 Diff 算法」。

## 单节点 Diff 算法

本节课采用简写示例区 A1-> A2（表示：type 更新前后都是，key 从 1 更新成了 2）

### 对于 reconcileSingleElement 的改动

当前支持的情况：
• A1->B1
• A1->A2
需要支持的情況：

- ABC -> A
  「单/多节点」是指「更新后是单/多节点」。

更细致的，我们需要区分 4 种情况：

- key 相同，type 相同== 复用当前节点，例如：A1B2C3 -> A1
- key 相同，type 不同== 不存在任何复用的可能性，例如：A1B2C3->B1
- key 不同，type 相同== 当前节点不能复用
- key 不同，type 不同== 当前节点不能复用

### 对于 reconcileSingleTextNode 的改动

类似 reconcileSingleElement

## 多节点的 Diff 算法

对于同级多节点 Diff 的支持单节点需要支持的情况：

- 插入 Placement
- 删除 ChildDeletion
  多节点需要支持的情况：
- 插入 Placement
- 删除 ChildDeletion
- 移动 Placement

### Diff 流程

整体流程分为 4 步。

1. 将 current 中所有同级 fiber 保存在 Map 中
2. 追历 newChild 数组，对于每个遍历到的 element，两种情況：
   a. 在 Map 中存在对应 current fiber，且可以复用
   b. 在 Map 中不存在对应 current fiber，或不能复用
3. 判断是插入还是移动
4. 最后 Map 中刺下的都标记删除
